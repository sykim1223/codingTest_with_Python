#선택정렬=================================================
#  : 처리되지 않은 데이터 중 "가장 작은 데이터를 선택하여 맨 앞에 있는 데이터와 바꾸는 방법"

# ****** 선택 정렬 소스코드 ******
# array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

# for i in range(len(array)):
#   min_index = i
#   for j in range(i+1, len(array)):
#     if array[min_index] > array[j]:
#       min_index = j
#   array[i], array[min_index] = array[min_index], array[i] #가장 작은 원소기를 앞으로

# print(array)
# ****** ******

#시간복잡도:
  # N번만큼 가장 작은 수를 맨 앞으로 보내야 함. 
  # 따라서 전체 연산 횟수는 O(N^2) = N+(N-1)+(N-2)+ ... + 2  _(상수가 2인 이유는 정렬되지 않은 마지막 요소에 대해 정렬을 수행할 필요가 없기 때문 )





#삽입 정렬 =================================================
#  : 처리되지 않은 데이터를 하나씩 골라 "적절한 위치에 삽입"_ 해당 요소가 어느 위치에 적절한지 매번 계산하여 정렬하는 방식
#선택 정렬에 비해 구현 난이도가 높지만, 보다 빠르게 동작함

#동작 방식:
  # - 앞쪽의 원소는 이미 정렬되어 있다고 가정하고, 뒤쪽의 원소를 앞쪽의 원소 중 한 곳으로 들어가도록 정렬

# ****** 삽입 정렬 소스코드 ******
# array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

# for i in range(1, len(array)): #첫번째 요소는 0번 인덱스의 요소는 이미 정렬된 상태이기 때문에, 1부터 시작
#   for j in range(i, 0, -1): #인덱스 i부터 1까지 1씩 감소하며 반복하는 문법
#     if array[j] < array[j-1]: #한 칸씩 왼쪽으로 이동
#       array[j], array[j-1] = array[j-1], array[j]
#     else: #자기보다 작은 데이터를 만나면 그 위치에서 멈춤
#       break

# print(array)
# ****** ******

#시간복잡도 : O(N^2).
  # 그러나 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작함.
  # 최선의 경우 O(N)의 시작 복잡도를 가짐





# 퀵 정렬 ========================================================
#  : "기준 데이터를 설정"하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
      # 가장 기본 적은 퀵 정렬은 첫번째 데이터를 기준데이터(Pivot)로 설정

# 동작 방법: 
  #   - 왼쪽에서부터 피벗보다 "큰" 데이터 선택, 오른쪽에서부터 피벗보다 "작은" 데이터 선택
  #   - 두 데이터의 위치를 서로 변경
  #   - 해당 과정을 반복하다가 "큰" 데이터와 "작은" 데이터의 위치가 엇갈리게 되면(위치를 변경할 필요 없이, 이미 작은 데이터가 큰 데이터의 왼편에 위치하게 되면) -> "작은" 데이터와 피벗의 위치를 변경
  #   - 이제 피벗을 기준으로 "왼쪽"에는 피벗보다 작은 값만 존재하고 "오른쪽"에는 피벗보다 큰 값만 존재하게 됨 (분할된 상태)
  #   - ["왼쪽" 데이터 묶음 정렬] 왼쪽에 대해 위의 과정을 수행
  #   - ["오른쪽" 데이터 묶음 정렬] 오른쪽에 대해 위의 과정을 수행
  # => 재귀적으로 수행! (재귀적으로 수행될 때 마다 작업의 크기가 작아지는 것을 확인)

# 시간 복잡도: 평균의 경우, O(NlogN) 임. 단, 최악의 경우 O(N^2)임. _ 피벗을 정하는 방법에 따라 최악의 경우가 될 수 있음