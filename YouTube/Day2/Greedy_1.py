#===================================================================#
#그리디 알고리즘: 현재 상황에서 "지금 당장 좋은 것"만 고르는 방법
#문제해결을 위한 최소한의 아이디어가 필요
#해법은 그 "정당성 분석"이 중요! 
# => 단순히 현재 좋은 것만 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토하는 과정이 필요
# 탐욕법이 최적의 해가 되는 문제만 나옴

#[문제1] 거스름돈 문제 ---------------------------------------------
# 거스름돈으로 사용할 500, 100, 50, 10원짜리 동전이 무한개 있다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때, 거슬러줘야 할 동전의 최소 개수는? 단, 거슬러줘야 할 돈은 N은 항상 10의 배수임.

# 아이디어: "가장 큰 화폐 단위부터" 거슬러줌

# 정당성 분석: 
# 가장 큰 화폐 단위부터 돈을 거슬러 주는게 최적의 해를 보장하는 이유는?
#   -> 가지고 있는 동전 중 "큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전을 조합해 다른 해가 나올 수 없기 때문"
#   if 800원 거슬러 줘야 하는데, 화폐단위가 500, 400, 100원이라면?
#     -> n(500, 100*3)=4 보다, n(400*2)=2 라는 작은 단위의 동전을 조합해 다른 해가 나올 수 있음.

# *** 소스 코드 ***
# N = 1260
# coin = [500, 100, 50, 10]

# result = 0

# for i in coin:
#   result = result + N//i
#   N = N%i

# print(f"{result}개 입니다.")
#  ******
# 시간 복잡도 분석: 화폐의 종류가 K라고 할 때, 시간복잡도는 O(K)임.



# [문제2] 1이 될 때까지 ----------------------------------------------
# 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하고자 함. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있음. 
#     1. N에서 1을 뺀다.
#     2. N을 K로 나눈다.
# 예를 들어 N이 17, K가 4라고 가정. 이 때 1번의 과정을 한 번 수행하면 N은 16이 됨. 이후 2번의 과정을 두 번 수행하면 N은 1이 됨. 결과적으로 전체 과정을 실행한 횟수는 3이 되며, 이는 N을 1로 만드는 최소 횟수임.
# N과 K가 주어질 때, N이 1이 될 때까지 1번 혹은 2번의 "과정을 수행해야 하는 최소 횟수"를 구하는 프로그램 작성하시오.
# 단, 1<= N <=100,000 이며 2<= K <= 100,000 임

# 아이디어: 주어진 N에 대해 "최대한 많이 나누기"를 수행하면 됨.
# N의 값을 줄일 때, 1을 빼는 작업보다 2 이상의 수로 나누는 작없이 수를 훨씬 많이 줄일 수 있음. (!당장 좋아보이는 나누기를 먼저 하는 것이 그리디와 적합함!)

# 정당성 분석: 가능하면 최대한 많이 나누는 작업이 최적의 해를 항상 보장할 수 있을 까? -> 2보다 큰 수로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있음

# *** 소스 코드1 ***
# N, K = map(int, input("N과 K를 입력하세요: ").split())
# count = 0

# while True:
#   if N ==1: 
#     break

#   if N%K == 0:
#     N = int(N/K)
#   else:
#     N = N-1
#   count = count + 1

# print(f"최소 횟수는 {count}입니다")
# ******
# *** 소스 코드2 ***
# N, K = map(int, input("N과 K를 입력하세요: ").split())
# count = 0

# while True:
# N이 K보다 큰 지 확인
#   if N < K:   
#     break   
# N이 K로 나누어 떨어지는 수가 될 때까지 1을 빼고, 그 횟수를 저장 
#   temp = (N // K)*K   
#   count = count + (N - temp)
#   N = temp // K
# 나누기를 한 번 수행했으므로 횟수를 한 번 추가
#   count = count + 1

# 마지막으로 남은 수에 대해 1을 빼어, 과정 1의 수행횟수 계산
# count = count + (N - 1)
  
# print(f"최소 횟수는 {count}입니다")
# ******

# 시간 복잡도 분석: 코드 2의 경우 로그시간까지 줄어듦.


# [문제3] 곱하기 혹은 더하기 ----------------------------------------------
# 각 자리가 숫자(0-9)로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어 결과적으로 "만들어질 수 있는 가장 큰 수를 구하는 프로그램"을 작성하시오.
# 단, +보다 x를 먼저 계산하는 일반적인 방식과 달리, "모든 연산은 왼쪽에서부터 순서대로" 이루어짐.
# 예를 들어 02984라는 문자열로 만들 수 있는 가장 큰 수는 0+2*9*8*4 = 576임.
#또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어짐.

# 아이디어: 대부분의 경우 '+'보다 'x'가 더 값이 커짐.
#단, 두 수 중 하나라도 0 혹은 1인 경우, 곱하기보다 더하기가 더 효율적임.
# 따라서 

# ***소스코드 1 ***
# S = input("숫자를 입력하세요: ")
# result = 0

# for i in S:
#   #연산을 위해 정수형 변환
#   i = int(i)
#   #곱하기보다 더하기가 더 나은 경우 확인
#   if i <=1 or result <= 1:
#     result = result + i
#   else:
#     result = result * i

# print(f"가장 큰 수는 {result}입니다.")

# ******

# 시간복잡도: 입력되는 숫자의 길이만큼.



# [문제4] 모험가 길드 ----------------------------------------------
# 한 마을에 모험가가 N명 있다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포도'를 측정했는데, '공포도'가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어짐.
# 모험가 길드장은 모험가 그룹을 안전하게 구성하고자 "공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여"해야 여행을 떠날 수 있도록 규정함.
# N명의 모험가에 대한 정보가 주어졌을 때, "여행을 떠날 수 있는 그룹 수의 최댓값"을 구하시오. 단, 1<= N <=100,000

#아이디어: 공포도를 오름차순으로 정렬하여, 수가 작은 그룹부터 만듦.
#"현재 그룹에 포함된 모험자의 수"가 "현재 확인하고 있는 공포도"보다 크거나 같다면 이를 그룹으로 설정.

# ***소스코드 1 ***
N = int(input("모험가의 수를 입력하세요: "))
data = list(map(int, input("각 모험가의 공포도를 입력하세요: ").split()))

data.sort()

result = 0 # 총 그룹의 수
party = 0 # 현재 그룹에 포험된 모험가의 수

for i in data: # 공포도가 낮은 모험가부터 확인
  party = party + 1 #현재 그룹에 해당 모험가 포함
  if party >= i: #현재 그룹에 포함된 모험가의 수가 현재 공포도 이상이면
    result = result + 1 # 그룹 결성
    party = 0 #현재 그룹에 포함된 모험가의 수 초기화

print(f"전체 그룹의 수는 {result}입니다.")
# ******

#시간 복잡도: 모험가의 수 만큼 반복. O(N)