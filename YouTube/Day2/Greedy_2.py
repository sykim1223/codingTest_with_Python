
# [문제2] 1이 될 때까지 ----------------------------------------------
# 어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하고자 함. 단, 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있음. 
#     1. N에서 1을 뺀다.
#     2. N을 K로 나눈다.
# 예를 들어 N이 17, K가 4라고 가정. 이 때 1번의 과정을 한 번 수행하면 N은 16이 됨. 이후 2번의 과정을 두 번 수행하면 N은 1이 됨. 결과적으로 전체 과정을 실행한 횟수는 3이 되며, 이는 N을 1로 만드는 최소 횟수임.
# N과 K가 주어질 때, N이 1이 될 때까지 1번 혹은 2번의 "과정을 수행해야 하는 최소 횟수"를 구하는 프로그램 작성하시오.
# 단, 1<= N <=100,000 이며 2<= K <= 100,000 임

# 아이디어: 주어진 N에 대해 "최대한 많이 나누기"를 수행하면 됨.
# N의 값을 줄일 때, 1을 빼는 작업보다 2 이상의 수로 나누는 작없이 수를 훨씬 많이 줄일 수 있음. (!당장 좋아보이는 나누기를 먼저 하는 것이 그리디와 적합함!)

# 정당성 분석: 가능하면 최대한 많이 나누는 작업이 최적의 해를 항상 보장할 수 있을 까? -> 2보다 큰 수로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있음

# *** 소스 코드1 ***
# N, K = map(int, input("N과 K를 입력하세요: ").split())
# count = 0

# while True:
#   if N ==1: 
#     break

#   if N%K == 0:
#     N = int(N/K)
#   else:
#     N = N-1
#   count = count + 1

# print(f"최소 횟수는 {count}입니다")
# ******
# *** 소스 코드2 ***
N, K = map(int, input("N과 K를 입력하세요: ").split())
count = 0

while True:
N이 K보다 큰 지 확인
  if N < K:   
    break   
N이 K로 나누어 떨어지는 수가 될 때까지 1을 빼고, 그 횟수를 저장 
  temp = (N // K)*K   
  count = count + (N - temp)
  N = temp // K
나누기를 한 번 수행했으므로 횟수를 한 번 추가
  count = count + 1

마지막으로 남은 수에 대해 1을 빼어, 과정 1의 수행횟수 계산
count = count + (N - 1)
  
print(f"최소 횟수는 {count}입니다")
# ******

# 시간 복잡도 분석: 코드 2의 경우 로그시간까지 줄어듦.
