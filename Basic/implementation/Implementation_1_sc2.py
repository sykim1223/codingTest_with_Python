# 구현(Implementation) 문제란?
# - 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 지칭
# - 예시) 
#   실수 연산을 다루고, 특정 소수점 자리까지 출력
#   문자열을 특정한 기준에 따라 끊어 처리하는 문제
#   적절한 라이브러리를 찾아서 사용해야 하는 문제
#   알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제

# "시뮬레이션 & 완전 탐색" 문제가 많이 나옴.
# -> 2차원 행렬이 많이 사용됨

#[문제1] 상하좌우 =====================================================#
# 여행가 A는 N x N 크기의 정사각형 공간 위에 서 있음. 이 공간은 1x1 크기의 정사각형으로 나누어져 있음. 가장 왼쪽 위 좌표는 (1,1)이며, 가장 오른쪽 아래 좌표는 (N,N)임. 
# 여행가 A는 상,하,좌,우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1,1)임. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여있음.
# 계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀 있으며, 각각 좌,우,위,아래 로 한칸 이동을 의미함
# 이때 , 여행가 A가 N x N 크기의 정사각형 공간을 벗어나는 움직임은 무시됨.
# 단, 1 <= N <= 100 이며, 1 <= 이동횟수 <= 100임.
# 여행가 A가 최종적으로 도착한 지점의 좌표(X,Y)를 출력하시오.


# *** 소스코드 2 ***
n = int(input("공간의 크기를 입력하세요: "))
plans = input("이동 계획을 입력하세요: ").split()

x, y = 1, 1

# L R U D에 따른 이동 방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

for plan in plans:
  #이동 후 좌표 구하기
  for i in range(len(move_types)):
    if plan == move_types[i]:
      nx = x+dx[i]
      ny = y+dy[i]

  #공간을 벗어나지 않는 경우, 이동 수행
  if 0< nx <=n and 0< ny <=n:
    x, y = nx, ny

print(f"최종 좌표는 {x} {y}입니다")